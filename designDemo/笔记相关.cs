using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace designDemo
{
    class 笔记相关
    {
    }



    /*
    系统程序域：系统程序域是第一个被创建的应用程序域，同时也是其他两个应用程序域的创建者。在该程序域初始化过程中，由它将msCorLib.dll这个程序集（这是一个很重要的程序集，.NET类型系统最基本的类型定义其中）加载到共享程序域中。此外，驻留的字符串也被保存在此系统程序域中。系统程序域的一个主要的任务是追踪其他所有应用程序域的状态，并负责加载和卸载它们；
共享程序域：共享程序域主要用于保存以“中立域（Domain-neutral Domain ）”加载的程序集容器。所谓“中立域 ”方式加载的程序集，就是说程序集并不被加载到当前的程序域中并被该程序域专用，而是加载到一个公共的程序域中被所有程序域共享。
默认程序域：我们的托管程序最终就运行在该程序域中，默认程序域可以通过System.AppDomain表示。

    


    
    */


    ///内存中出现不同步原因：
    ///处理器可以使用高速缓存加速对内存的访问（或者编译器可以将值存储到寄存器中以便进行更快的访问）。在一些多处理器体系结构上，假如在一个处理器的高速缓存中修改了内存位置，没有必要让其它处理器看到这一修改，直到刷新了写入器的高速缓存并且使读取器的高速缓存无效。 

//    这表示在这样的系统上，对于同一变量，在两个不同处理器上执行的两个线程可能会看到两个不同的值！这听起来很吓人，但它却很常见。它只是表示在访问其它线程使用或修改的数据时，必须遵循某些规则。 
　　
//　　Volatile 比同步更简单，只适合于控制对基本变量（整数、布尔变量等）的单个实例的访问。当一个变量被声明成 volatile，任何对该变量的写操作都会绕过高速缓存，直接写入主内存，而任何对该变量的读取也都绕过高速缓存，直接取自主内存。这表示所有线程在任何时候看到的 volatile 变量值都相同。 

//了解更多


}
